package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;

import java.util.LinkedList;
import java.util.List;

/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @author Joel Uban
 * @pso 17
 * @date October 21, 2016
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {
        //TODO:implement

        //System.out.println("\nClient's master hash: " + this.masterHash);

        if (pathSiblings.size() < 2) {
            return false;
        }

        boolean matched = false;

        int index = 0;
        int nodeIndex;

        String hash;
        IMerkleTree.Node temp;

        if (pathSiblings.get(index).getIndex() % 2 == 0) {
            hash = Configuration.hashFunction.concatenateHash(pathSiblings.get(index), pathSiblings.get(index + 1));
            nodeIndex = pathSiblings.get(index).getIndex() / 2;
        }
        else {
            hash = Configuration.hashFunction.concatenateHash(pathSiblings.get(index + 1), pathSiblings.get(index));
            nodeIndex = pathSiblings.get(index).getIndex() / 2;
        }

        temp = new IMerkleTree.Node(hash, nodeIndex);

        index = 2;

        while (index < pathSiblings.size()) {
            if (temp.getIndex() % 2 == 0) {
                nodeIndex = temp.getIndex() / 2;
                hash = Configuration.hashFunction.concatenateHash(temp, pathSiblings.get(index));
                temp = new IMerkleTree.Node(hash, nodeIndex);
            }
            else {
                nodeIndex = temp.getIndex() / 2;
                hash = Configuration.hashFunction.concatenateHash(pathSiblings.get(index), temp);
                temp = new IMerkleTree.Node(hash, nodeIndex);
            }
            index++;
        }

        if (hash != null) {
            //System.out.println("Hash: " + hash + ", Master Hash: " + this.masterHash + "\n");
            matched = hash.equals(this.masterHash);
        }

        /*
         * You need to use Configuration.hashFunction and this.masterHash to determine a match
         */
        return matched;
    }
}
